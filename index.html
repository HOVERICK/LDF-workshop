<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>방배정표 조회</title>

<!-- XLSX 파서 -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<style>
  *{box-sizing:border-box} html{-webkit-text-size-adjust:100%}
  body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans KR","Malgun Gothic",Arial,sans-serif;margin:0;background:#f7f7f9;color:#111}
  .wrap{max-width:980px;margin:0 auto;padding:24px}
  h1{font-size:20px;margin:0 0 14px}
  .top{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .search{display:flex;gap:8px;width:100%}
  input[type="text"]{flex:1;padding:14px 16px;border:1px solid #ddd;border-radius:12px;background:#fff;font-size:16px}
  button{padding:14px 16px;border:1px solid #ddd;border-radius:12px;background:#111;color:#fff;font-size:15px;white-space:nowrap;cursor:pointer}
  .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid #eee;background:#fff;border-radius:999px;padding:8px 10px}
  .hint{font-size:12px;color:#666;margin:10px 0}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:16px}
  @media (max-width:760px){ .grid{grid-template-columns:1fr} .wrap{padding:16px} }
  .card{background:#fff;border:1px solid #eee;border-radius:14px;padding:14px}
  .t{font-size:13px;color:#666;margin-bottom:6px}
  .v{font-size:16px;line-height:1.5;word-break:keep-all}
  .muted{color:#888}
  .err{color:#b00020;font-size:13px;margin-top:10px;white-space:pre-line}
  .hidden{display:none}
  .loading{font-size:13px;color:#666;margin-top:10px}
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <h1>방배정표 조회</h1>
    <div id="adminPill" class="pill hidden"></div>
  </div>

  <div class="search">
    <input id="q" type="text" placeholder="이름을 입력하세요 (예: 홍길동)" enterkeyhint="search" autofocus>
    <button id="btn">검색</button>
    <button id="reload" class="hidden">데이터 새로고침</button>
  </div>
  <div id="hint" class="hint">※동명이인이 있을 시 소속 부서를 확인해 주세요.</div>
  <div id="loading" class="loading hidden">데이터 불러오는 중…</div>
  <div id="err" class="err hidden"></div>

  <div id="results" class="grid"></div>
</div>

<script>
/* ===== 파일 경로 ===== */
const ROOMING_URL = "data/rooming.xlsx"; // 루밍리스트(시트별 1차/2차 …, 최소: 성명/방번호)
const ROSTER_URL  = "data/roster.xlsx";  // 조 포함 리스트(최소: 성명/소속부문(or 부서)/차수)
const CONFIG_URL  = "data/config.json";  // {"active_batch":"1"} (선택)

/* ===== 파라미터/모드 ===== */
const params = new URLSearchParams(location.search);
const isAdmin = params.get("admin") === "1";

/* ===== 별칭 ===== */
const aliases = {
  name:  ["성명","이름","예약자명","신청자명","참여자명","성 명","Name","name"],
  room:  ["방번호","객실","룸","room","Room","객실번호","호실","호수","배정호수","객실명","객실호수"],
  division:["소속부문","부문","본부","사업부","소속","Division","division"],
  dept:  ["부서명","부서","소속부서","팀명","팀","근무부서","Department","dept"],
  batch: ["차수","회차","신청차수","차 수","차수(신청)","Batch","batch"]
};

/* ===== 상태 ===== */
let activeBatch = "1";     // 기본값
let roomingRows = [];      // [{name, room}]
let rosterRows  = [];      // [{name, division, dept, batch}]
let byRoom = new Map();    // room => [names...]
let personIndex = new Map();// normName(name) => [{name, division, dept, batch}...]

/* ===== 유틸 ===== */
const $ = s => document.querySelector(s);
const norm = s => (s ?? "").toString().replace(/^\uFEFF/,"").replace(/[\u200B-\u200D\u2060]/g,"").trim();
const normName = s => norm(s).replace(/\s+/g,"").replace(/[·ㆍ]/g,"");
const onlyDigits = s => (s||"").toString().match(/\d+/)?.[0] || "";
function show(el, yes){ el.classList.toggle("hidden", !yes); }

/* ===== fetch ===== */
async function fetchArrayBuffer(url){
  const r = await fetch(url, {cache:"no-store"});
  if(!r.ok) throw new Error(`파일을 불러올 수 없습니다: ${url} (HTTP ${r.status})`);
  return await r.arrayBuffer();
}

/* ===== XLSX helpers ===== */
function toMatrix(ws){ return XLSX.utils.sheet_to_json(ws, {header:1, defval:""}); }
function scoreHeader(cells, wantKeys){
  const set = cells.map(c => norm(c).replace(/\s+/g,"").toLowerCase());
  let score=0;
  for(const want of wantKeys){
    const cand = aliases[want];
    const hit = set.some(v => cand.some(a => v.includes(norm(a).replace(/\s+/g,"").toLowerCase())));
    if(hit) score++;
  }
  return score;
}
function findHeaderIdx(matrix, wantKeys){
  let best={idx:0,score:-1};
  for(let i=0;i<Math.min(30,matrix.length);i++){
    const row=matrix[i]||[];
    const nonEmpty = row.filter(v=>norm(v).length>0).length;
    if(nonEmpty < 2) continue;
    const sc = scoreHeader(row, wantKeys);
    if(sc > best.score) best={idx:i,score:sc};
  }
  return best.score>=1 ? best.idx : 0;
}
function buildColMap(header, aliasMap){
  const idx = {};
  const H = header.map(h => norm(h).replace(/\s+/g,"").toLowerCase());
  for(const [key, list] of Object.entries(aliasMap)){
    let found = -1;
    for(let i=0;i<header.length;i++){
      if(list.some(a => H[i].includes(norm(a).replace(/\s+/g,"").toLowerCase()))){ found=i; break; }
    }
    idx[key]=found;
  }
  return idx;
}

/* ===== 시트 선택 ===== */
function pickSheetForBatch(wb, batch){
  const names = wb.SheetNames || [];
  const b = String(batch);
  const normS = s => norm(s).toLowerCase().replace(/\s+/g,"");
  return names.find(n => normS(n).includes(b+"차")) ||
         names.find(n => normS(n).match(new RegExp(`(^|[^\\d])${b}([^\\d]|$)`))) ||
         names[0];
}

/* ===== active batch ===== */
async function loadActiveBatch(){
  const urlB = params.get("b");
  if(urlB){ activeBatch = norm(urlB); return; }
  try{
    const r = await fetch(CONFIG_URL, {cache:"no-store"});
    if(r.ok){
      const j = await r.json();
      if(j && j.active_batch) activeBatch = norm(j.active_batch);
    }
  }catch(e){ /* ignore */ }
}

/* ===== loaders ===== */
async function loadRooming(){
  const buf = await fetchArrayBuffer(ROOMING_URL);
  const wb = XLSX.read(buf, {type:"array"});
  const sheet = pickSheetForBatch(wb, activeBatch);
  const ws = wb.Sheets[sheet];
  if(!ws) throw new Error(`rooming.xlsx에 '${activeBatch}차' 시트를 찾지 못했습니다. (시트 후보: ${wb.SheetNames.join(", ")})`);
  const mat = toMatrix(ws);
  const hIdx = findHeaderIdx(mat, ["name","room"]);
  const header = mat[hIdx] || [];
  const data = mat.slice(hIdx+1);
  const cmap = buildColMap(header, {name:aliases.name, room:aliases.room});
  if(cmap.name<0 || cmap.room<0){
    throw new Error(`rooming.xlsx(${sheet})에서 열 식별 실패: name=${cmap.name}, room=${cmap.room}\n헤더: ${header.join(" | ")}`);
  }
  const out=[];
  for(const row of data){
    const nameCell = norm(row[cmap.name]);
    const room = norm(row[cmap.room]);
    if(!nameCell) continue;

    // (중요) 한 셀에 여러 이름이 들어온 경우 분리 저장
    const parts = nameCell
      .split(/[,/&]|·|ㆍ|，|、/g)   // 콤마/슬래시/중점 등 구분자 허용
      .map(s => norm(s))
      .filter(Boolean);

    if (parts.length === 0) continue;
    for (const p of parts) {
      out.push({ name: p, room });
    }
  }
  return out;
}
async function loadRoster(){
  const buf = await fetchArrayBuffer(ROSTER_URL);
  const wb = XLSX.read(buf, {type:"array"});
  const all=[];
  for(const sheet of wb.SheetNames){
    const ws = wb.Sheets[sheet];
    const mat = toMatrix(ws);
    const hIdx = findHeaderIdx(mat, ["name","division","dept","batch"]);
    const header = mat[hIdx] || [];
    const data = mat.slice(hIdx+1);
    const cmap = buildColMap(header, {
      name:aliases.name, division:aliases.division, dept:aliases.dept, batch:aliases.batch
    });
    for(const row of data){
      const name = cmap.name>=0 ? norm(row[cmap.name]) : "";
      if(!name) continue;
      const division = cmap.division>=0 ? norm(row[cmap.division]) : "";
      const dept     = cmap.dept>=0 ? norm(row[cmap.dept]) : "";
      const batchRaw = cmap.batch>=0 ? norm(row[cmap.batch]) : ""; // 반드시 있어야 함(없으면 제외 예정)
      all.push({name, division, dept, batch: batchRaw});
    }
  }
  // (중요) 같은 차수(활성 차수) 데이터만 사용 — 차수 없는 행은 제외
  const filt = all.filter(r => onlyDigits(r.batch) === activeBatch);
  return filt;
}

/* ===== 인덱스 ===== */
function buildIndexes(){
  byRoom.clear(); personIndex.clear();
  for(const r of roomingRows){
    const key = r.room || "(미배정)";
    if(!byRoom.has(key)) byRoom.set(key, []);
    const arr = byRoom.get(key);
    if(!arr.includes(r.name)) arr.push(r.name);
  }
  for(const r of rosterRows){
    const k = normName(r.name);
    if(!personIndex.has(k)) personIndex.set(k, []);
    personIndex.get(k).push(r); // 이미 동일 차수만 들어있음
  }
}

/* ===== 조회 보조 (같은 차수에서만) ===== */
function findDivisionOrDept(name){
  const list = personIndex.get(normName(name)) || [];
  const rec = list[0]; // 같은 차수만 인덱싱되어 있음
  return rec?.division || rec?.dept || "정보없음";
}

/* ===== 렌더: 방(룸) 단위 카드 + 이름(소속부문) ===== */
function renderResultsGroupedByRoom(roomList){
  const wrap = $("#results"); 
  wrap.innerHTML = "";

  if(!roomList.length){
    wrap.innerHTML = `<div class="card"><div class="v muted">검색 결과가 없습니다. 철자(공백 포함)를 확인해 주세요.</div></div>`;
    return;
  }

  // 방번호 정렬(숫자 우선)
  const sortKey = r => parseInt((r||"").toString().match(/\d+/)?.[0] || "999999", 10);
  roomList.sort((a,b)=> sortKey(a) - sortKey(b));

  for(const room of roomList){
    const namesInRoom = (byRoom.get(room) || []);
    const formatted = namesInRoom.map(n=>{
      const div = findDivisionOrDept(n); // 같은 차수에서만 찾음
      return `${n}(${div})`;
    }).join(", ");

    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="t">참여자 성함</div>
      <div class="v">${formatted || "<span class='muted'>정보없음</span>"}</div>

      <div class="t" style="margin-top:8px">방 번호</div>
      <div class="v">${room || "<span class='muted'>(미배정)</span>"}</div>
    `;
    wrap.appendChild(card);
  }
}

/* ===== 검색 핸들러: 사람 → 그 사람이 속한 방(들)로 묶어 보여주기 ===== */
function handleSearch(){
  const term = norm($("#q").value);
  if(!term){ $("#results").innerHTML=""; return; }
  const key = normName(term);
  const hits = roomingRows.filter(r => normName(r.name).includes(key));
  const rooms = Array.from(new Set(hits.map(r => r.room || "(미배정)")));
  renderResultsGroupedByRoom(rooms);
}

/* ===== 초기화 ===== */
async function init(){
  $("#err").textContent=""; show($("#err"), false);
  show($("#loading"), true);
  show($("#reload"), isAdmin);
  try{
    await loadActiveBatch();
    if(isAdmin){ $("#adminPill").classList.remove("hidden"); $("#adminPill").textContent=`관리자: 활성 차수 ${activeBatch}차`; }

    roomingRows = await loadRooming();   // 활성 차수 시트만
    rosterRows  = await loadRoster();    // 활성 차수 행만
    buildIndexes();

    show($("#loading"), false);

    const preset = params.get("name");
    if(preset){ $("#q").value=preset; handleSearch(); }
  }catch(e){
    show($("#loading"), false);
    $("#err").textContent =
      "데이터 로딩 오류:\n" + e.message +
      "\n\n점검:\n1) 레포에 data/rooming.xlsx, data/roster.xlsx 존재\n" +
      "2) rooming.xlsx엔 '1차/2차' 등 시트가 있고, 시트에 성명/방번호 열 존재\n" +
      "3) roster.xlsx엔 성명/소속부문(또는 부서)/차수 열 존재(필수), 차수는 숫자 포함\n" +
      "4) 주소에 ?b=1 또는 ?b=2 로 활성 차수 지정 가능";
    show($("#err"), true);
    console.error(e);
  }
}

/* 이벤트 */
$("#btn").addEventListener("click", handleSearch);
$("#q").addEventListener("keydown", e=>{ if(e.key==="Enter") handleSearch(); });
$("#reload").addEventListener("click", init);

/* run */
init();
</script>
</body>
</html>
